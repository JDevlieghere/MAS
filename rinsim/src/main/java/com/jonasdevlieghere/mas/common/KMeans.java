package com.jonasdevlieghere.mas.common;


import org.apache.commons.math3.random.MersenneTwister;
import org.apache.commons.math3.random.RandomGenerator;
import rinde.sim.core.graph.Point;

import java.util.ArrayList;
import java.util.NoSuchElementException;

/**
 * Naive 2D implementation of the K-Means Algorithm in Java.
 */
public class KMeans {

    public static final int MAX_ITERATIONS = 1000;

    /**
     * List of points
     */

    private ArrayList<Point> points;
    /**
     * List of centroids
     */
    private ArrayList<Point> centroids;

    /**
     * List of clusters
     */
    private ArrayList<Cluster> clusters;

    /**
     * The number of clusters
     */
    private int k;

    /**
     * Random Generator
     */
    private RandomGenerator random;

    /**
     * Initialize a new instance of the k-means algorithm.
     *
     * @param   points
     *          The list of points to cluster.
     * @param   k
     *          The desired amount of clusters.
     */
    public KMeans(ArrayList<Point> points, int k, int seed) {
        setNbClusters(k);
        setPoints(points);
        this.random = new MersenneTwister(seed);
    }

    private void setNbClusters(int k){
        if(k <= 1)
            throw new IllegalArgumentException("The amount of clusters should be greater than 1.");
        this.k = k;
    }

    /**
     * Get the number of clusters.
     *
     * @return  The number of clusters
     */
    public int getNbClusters(){
        return this.k;
    }

    private void setPoints(ArrayList<Point> points) {
        if(points.size() < getNbClusters())
            throw new IllegalArgumentException("The amount of points should be greater than or equal to the amount of clusters.");
        this.points = points;
    }

    /**
     * Guess an initial position for the centroids of the k clusters.
     */
    private void initCentroids(){
        this.centroids = new ArrayList<Point>();
        Cluster initial = new Cluster(this.points);
        for(int i = 0; i < getNbClusters(); i++){
            Point c = initial.getCenter();
            double x = c.x*random.nextDouble();
            double y = c.y*random.nextDouble();
            centroids.add(new Point(x,y));
        }
    }

    /**
     * Create k empty clusters
     */
    private void initClusters() {
        this.clusters = new ArrayList<Cluster>();
        for (int i = 0; i < getNbClusters(); i++) {
            clusters.add(new Cluster());
        }
    }

    /**
     * Get a clusters generated by the algorithm.
     *
     * @return A list of clusters
     */
    public ArrayList<Cluster> getClusters(){
        initCentroids();
        boolean improved = true;
        int iterations = 0;
        while(improved && iterations++ < MAX_ITERATIONS){
            /**
             * Assign each point to the cluster with the cluster with the nearest centroid.
             */
            initClusters();
            for(Point p : points){
                double bestDistance = Double.POSITIVE_INFINITY;
                int cluster = -1;
                for(int i = 0; i < getNbClusters(); i++){
                    double distance = Point.distance(p, centroids.get(i));
                    if(distance < bestDistance){
                        bestDistance = distance;
                        cluster = i;
                    }
                }
                clusters.get(cluster).add(p);
            }
            /**
             * Update the centroid of each cluster according to the points currently assigned.
             * If all elements are assigned to a single cluster, causing a cluster to have no centroid,
             * start over with a new approximation for the centroids.
             */
            ArrayList<Point> newCentroids = new ArrayList<Point>();
            try{
                for(int i = 0; i < getNbClusters(); i++){
                    newCentroids.add(clusters.get(i).getCenter());
                }
                improved = !centroids.equals(newCentroids);
                this.centroids = newCentroids;
            }catch (NoSuchElementException e){
                initCentroids();
            }
        }
        return this.clusters;
    }
}